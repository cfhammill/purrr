% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reduce.R
\name{reduce_while}
\alias{reduce_while}
\alias{reduce2_while}
\alias{reduce_while_right}
\alias{reduce2_while}
\title{Reduce a list to a single value by iterative applying a binary function}
\usage{
reduce_while(.x, .f, .p, ..., .init, .hind = TRUE)

reduce2_while(.x, .y, .f, .p, ..., .init, .hind = TRUE)

reduce_while_right(.x, .f, .p, ..., .init, .hind = TRUE)

reduce2_while(.x, .y, .f, .p, ..., .init, .hind = TRUE)
}
\arguments{
\item{.x}{A list or atomic vector.}

\item{.f}{For \code{reduce()}, a 2-argument function. The function will be
passed the accumulated value as the first argument and the "next" value
as the second argument.

For \code{reduce2()}, a 3-argument function. The function will be passed the
accumulated value as the first argument, the next value of \code{.x} as the
second argument, and the next value of \code{.y} as the third argument.}

\item{.p}{A predicate function to apply to the current result, evaluations is
stopped when \code{.p} evaluates to FALSE, or there are no elements to consume.}

\item{...}{Additional arguments passed on to \code{.f}.}

\item{.init}{If supplied, will be used as the first value to start
the accumulation, rather than using \code{x[[1]]}. This is useful if
you want to ensure that \code{reduce} returns a correct value when \code{.x}
is empty. If missing, and \code{x} is empty, will throw an error.}

\item{.hind}{Whether the results are hind facing. Default is the \code{TRUE} which
returns the last result that passes \code{.p}. Setting to \code{FALSE} returns
the result that first fails \code{.p}.}

\item{.y}{For \code{reduce2()}, an additional argument that is passed to
\code{.f}. If \code{init} is not set, \code{.y} should be 1 element shorter than
\code{.x}.}
}
\description{
\code{reduce_while} encapsulates the pattern of combining elements with
a two argument function until a condition is met or until all elements have
been consumed. \code{reduce_while} combines
elements from left to right, \code{reduce_while_right} combines from right to left.
\code{reduce2_while} and sided versions extend this to functions of three arguments.
By default results are the accumulated value up to, but not including the first
failing test. This can be configured with the \code{.hind} argument.
}
\examples{
1:6 \%>\% reduce_while(`+`, ~ . < 5) ## adds 1 + 2, then fails on 3
1:6 \%>\% reduce_while(`+`, ~ . < 5, .hind = FALSE) ## fails on +3, but returns that result
1:6 \%>\% reduce_while_right(`+`, ~ . < 5)
1:6 \%>\% reduce_while_right(`+`, ~ . < 5, .hind = FALSE)

paste2 <- function(x, y, sep = ".") paste(x, y, sep = sep)
letters[1:4] \%>\% reduce_while(paste2, ~ nchar(.) < 5)
letters[1:4] \%>\% reduce_while(paste2, ~ nchar(.) < 5, .hind = FALSE)
letters[1:4] \%>\% reduce2_while(c("-", ".", "-"), paste2, ~ !grepl("\\\\.", .))
letters[1:4] \%>\% reduce2_while(c("-", ".", "-"), paste2, ~ !grepl("\\\\.", .), .hind = FALSE)
}
